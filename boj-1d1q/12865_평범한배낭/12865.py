import sys
sys.stdin = open("12865.txt", 'r')
N, K = map(int, sys.stdin.readline().split())
dp = [[0] * (K + 1) for _ in range(N + 1)]
for i in range(1, N + 1):
    w, v = map(int, sys.stdin.readline().split())
    for j in range(1, K + 1):
        if j >= w:
        # 만약 현재 가방의 여유 공간이 j 일 때
        # 넣으려는 물건의 무게 w 가 충분히 들어갈 수 있다면
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v)
            # 이전 것만 넣고 현상유지 할건지 또는 이전것 넣으면서 지금것도 넣을건지, 왜냐하면 안 넣을 수 있으면 안 넣는게 나중 갈수록 유리하니까.
            # 이전 것을 넣는데 오히려 w 를 빼는 이유 : 
            # 여유 공간이 j 라는 어떤 양 인데 거기서 w 만큼을 뺀다 == w 만큼 넣었다고 가정하는것임
            # 왜 넣었는데 + 가 아니고 - 냐?
            # 여유 공간에 어떤 물건을 넣었으니, 여유 공간 j 에서 넣은 물건의 양 만큼인 w 를 빼는것
            # 즉 j - w 는 j 에 w 만큼 넣었을 때 남은 공간
            # j + w 라는 계산을 하게 되면 배낭에 원래 w 가 있던 상태에서 w 를 도로 빼버린다는 의미이다.
            # 정리하면
            # max(
                # 현상 유지, w 만큼을 더 넣은 무게일 때의 가치 + 지금 물건의 가치 (== dp[j - w] 만큼의 여유가 있었을 때 했던 최선의 선택에 w 를 넣은 것 + 지금 물건의 가치)
            # )
        else:
            dp[i][j] = dp[i - 1][j]
            # 더 이상 여유 공간이 없으므로 현상 유지로 만족
print(dp[N][K])