N = int(input())
A = [*map(int, input().split())]
B = A[::-1]
dp = [1] * (N)
dp2 = [1] * (N)
for i in range(1, N):
    for j in range(i):
        if A[i] > A[j]:
            dp[i] = max(dp[i], dp[j] + 1)
        if B[i] > B[j]:
            dp2[i] = max(dp2[i], dp2[j] + 1)
dp2 = dp2[::-1]
res = []
for i in range(N):
    res.append(dp[i] + dp2[i] - 1)
print(max(res))
# 증가하는 수열을 구한다.
# 그리고 해당 수열에서 어떤 index일 때 길이가 n이었다면(dp[i] = n), 그 n을 길이로 가지는 순간부터 index의 끝까지 가면서 가장 긴 감소하는 수열을 구하면 된다.
# 가장 긴 감소하는 수열을 구하기 위해 가장 긴 증가하는 수열을 뒤집어서 생각하면 된다.
# 따라서 원본 수열을 뒤집은 다음 가장 긴 증가하는 수열을 구해보면,
# 해당 뒤집은 수열은 맨 처음부터 증가하다가 우리가 맨 처음에 구했던 dp[i] = n인 순간을 마주치게 될 것이다.
# 그것이 바로 원본 수열의 맨 뒤에서부터 출발해서 dp[i] = n이 될 때까지 가장 긴 감소하는 수열이나 마찬가지이다.
# 따라서 원본 수열과 뒤집은 수열 모두 증가하는 수열을 구해준 뒤 각각의 수열에서 같은 index를 가지는 dp값을 서로 더해주면 된다.
# 그런데 역으로 된 부분을 더해줄 때 같은 인덱스가 겹쳐지면서(5까지 길이를 쟀는데 다시 5부터 잼)두 번 더해지는 것과 다름없다.
# 따라서 마지막 결과에서 -1만큼의 길이를 빼야 된다.