문제는 다음와 같은 규칙을 가진다.



1 번째 작은 수 부터 2 번째 작은 수 까지는 한 자리 조합,  => 4 , 7,        개수는 2개 => 2^1

3 번째 작은 수 부터 6 번째 작은 수 까지는 두 자리 조합,  => 44, 47, 74, 77,    개수는 4개 => 2^2

7 번째 작은 수 부터 14 번째 작은 수 까지는 세 자리 조합,  => 444 ~ 777,      개수는 8개 => 2^3

15 번째 작은 수 부터 30 번째 작은 수 까지는 네 자리 ...

이것은 마치 (2 ** n) - 1 부터 (2 ** (n + 1)) - 2 사이의 범위와 같다.



어떤 특정 범위를 구하기 위해 n 을 찾을 필요가 있는데,

n = 0 부터 1 씩 더해가면서 범위를 정해줄 필요가 있다.



예를 들어 K = 3 이고 3 번째 작은 수를 찾으려고 한다면,

아래와 같은 모양이 된다.



[2^2를 이진수 변환] ~~ K=3 ~~ [(2^3) - 1 을 이진수 변환]



범위를 잘 정했다면 아까 봤던 자리수를 잘 떠올려 본다.

K 가 3 ~ 6 이라면 세 번째 작은 수 부터 여섯 번째 작은 수 까지인데,

그 범위에서는 4와 7이 두 자리에서 조합이 이루어진다. => 00, 01, 10, 11 => 44, 47, 74, 77

이것은 이진수 0 과 1 의 조합 규칙과 같은데,

모든 조합을 따져보기 위해서는 00 부터 11 까지의 이진수 조합이 필요하다.



i ~~ K ~~ j

00 ~~ ?? ~~ 11

2^2를 이진수 변환 ~~ K = 3 ~~ (2^3) - 1 을 이진수 변환



i 부터 j 까지이고, 그 사이에 낀 K 번째 값이니까,

i 번째부터 K 까지 추가로 몇 칸 가주면 목표하는 값인 이진수 조합이 나온다.

그렇다면 이진수 변환은 i 부터 시작을 해주면 된다고 생각했다.

완전히 0으로 된 조합에서 +몇 을 해준 값이 앞으로 간 값이 정답인 K 번째 값 인데,

다시 생각해보니 i 를 그대로 이진수 변환하게 되면 필요한 자리수에서 하나 모자른 이진수 값이 나온다. => 11

이 떄, i + 1 을 해주면 앞의 1 을 제외한 나머지 자리는 모두 0 인 이진수가 나온다. => 11 + 1 = 100